除了使用`@Scheduled`注解来配置定时任务外，Spring还提供了其他的定时任务方式，包括：

1. 实现`Runnable`接口，并使用`ScheduledExecutorService`来执行任务：

```java
import org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Component
public class MyTask implements Runnable {
    @Resource(name = "scheduledExecutorFactoryBean")
    private ScheduledExecutorFactoryBean scheduledExecutorFactoryBean;

    @PostConstruct
    public void init() {
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        executorService.scheduleAtFixedRate(this, 0, 5, TimeUnit.SECONDS);
        scheduledExecutorFactoryBean.setScheduledExecutor(executorService);
    }

    @Override
    public void run() {
        // 执行任务的代码
    }
}
```

在上面的示例中，我们实现了`Runnable`接口，并在`init`方法中使用`ScheduledExecutorService`来执行任务。通过使用`ScheduledExecutorService`，我们可以实现并发执行定时任务，提高任务执行效率。

2. 使用Quartz框架来实现定时任务：

```java
import org.quartz.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MyTask {
    @Autowired
    private Scheduler scheduler;

    public void start() throws SchedulerException {
        JobDetail jobDetail = JobBuilder.newJob(MyJob.class)
                .withIdentity("myJob", "myGroup")
                .build();

        Trigger trigger = TriggerBuilder.newTrigger()
                .withIdentity("myTrigger", "myGroup")
                .withSchedule(CronScheduleBuilder.cronSchedule("0/5 * * * * ?"))
                .build();

        scheduler.scheduleJob(jobDetail, trigger);
    }
}

public class MyJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        // 执行任务的代码
    }
}
```

在上面的示例中，我们使用Quartz框架来实现定时任务。首先，我们定义了一个名为`MyTask`的组件，并在其中添加了一个名为`start`的方法。在该方法中，我们创建了一个`JobDetail`和一个`Trigger`，并使用`Scheduler`来调度任务。同时，我们还定义了一个名为`MyJob`的类，并实现了`Job`接口，在其中编写了任务的执行代码。通过使用Quartz框架，我们可以实现更加灵活和复杂的定时任务。